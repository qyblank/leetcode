/*
169. 多数元素
        简单
        相关标签
        相关企业
        给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

        你可以假设数组是非空的，并且给定的数组总是存在多数元素。



        示例 1：

        输入：nums = [3,2,3]
        输出：3
        示例 2：

        输入：nums = [2,2,1,1,1,2,2]
        输出：2


        提示：
        n == nums.length
        1 <= n <= 5 * 104
        -109 <= nums[i] <= 109


        进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题

*/
package code;

import java.util.Arrays;

public class 多数元素 {
    public int majorityElement(int nums[]){
        //思路：数量超过n/2的元素，在数组下标n/2处必定是该元素
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }


  /*  这个算法是用来解决“多数元素”问题的一个高效解法，这个问题是经典的“Boyer-Moore 投票算法”的应用。以下是算法的分析：

    算法概述
    Boyer-Moore 投票算法的基本思想是，在遍历数组的过程中，维护一个候选多数元素和一个计数器。算法分为两个阶段：候选阶段和计数阶段。

    代码分析
    在提供的代码中，算法被分成了两个方法：majorityElement 和 select。

    majorityElement 方法
    这是主方法，接受一个整数数组 nums 作为参数。
    它调用 select 方法来找到一个多数元素的位置，然后返回该位置的元素作为结果。
    select 方法
    这个方法是算法的核心，它接受一个整数数组 nums 和一个当前索引 cur 作为参数。
    它初始化一个计数器 cnt 为 1，并设置下一个元素的索引 next 为 cur + 1。
    然后，它进入一个循环，从下一个元素开始遍历数组，并对以下情况进行处理：
    如果当前元素与候选元素（即 nums[cur]）相同，计数器 cnt 增加。
    如果当前元素与候选元素不同，计数器 cnt 减少。
    如果 cnt 变为 0，意味着我们已经找到了一个候选元素，并且它不是真正的多数元素，或者它与数组中其他元素的数量相同。此时，我们将下一个元素作为新的候选元素，并递归调用 select 方法。
    循环继续，直到我们找到一个真正的多数元素，或者 next 达到数组的末尾。
    算法正确性
    这个算法的正确性基于以下事实：如果我们从一个多数元素开始，并逐个地消除与其不同的元素，最终剩下的元素一定是多数元素。因为多数元素出现的次数超过数组长度的一半，所以在消除过程中，多数元素的数量总是比其他元素的数量多。

    时间复杂度和空间复杂度
    时间复杂度：O(n)，其中 n 是数组的长度。算法只遍历了数组一次。
    空间复杂度：O(1)，算法只使用了常数级别的额外空间。
    总结
    这个算法是一个线性时间复杂度的解法，它不需要对整个数组进行排序，也不需要额外的空间来存储计数信息，因此在处理大型数据集时非常高效。此外，它也是原地算法，因为它不需要额外的存储空间。*/
    public int majorityElement2(int[] nums) {
        int idx = select(nums, 0);
        return nums[idx];
    }

    private int select(int[] nums, int cur) {//cur为候选多数元素
        int next = cur + 1;
        int cnt = 1;//计数器
        while (next < nums.length) {
            if (nums[next] == nums[cur]) {
                cnt++;//找到相同元素则计数器加一
            } else {
                cnt--;//不同元素则计数器减一，
            }
            next++;
            if (cnt == 0) {
                return select(nums, next);//当计数器归零则进行递归，传入新的候选元素，
            }
        }
        return cur;//返回的候选元素必定是在某次递归中相同元素多余不同元素的元素，满足>n/2条件
    }

}
